== Common problems and their solutions

=== System file encoding

Most Java tools use the system file encoding when no specific encoding is specified.
This means that running the same build on machines with different file encoding can yield different outputs.
Gradle currently does only track that no file encoding has been specified on a task basis - but it does not track the system encoding of the JVM it is using.
This can cause incorrect builds. You should always set the file system encoding to avoid these kind of problems.

=== Environment variable tracking

Gradle does currently not track environment variables for tasks.
For example for the `Test` tasks it is completely possible that the outcome depends on a few environment variables.
To ensure that only the right artifacts are re-used between builds you need to add environment variables as an input to the tasks depending on them.

Absolute paths are often passed as environment variables, too. You need to pay attention what you add as an input to the task in this case. If you add the absolute path then it will be very hard to re-use task outputs between different machines.
You would need to ensure that the absolute path is the same between machines. Most times it makes sense to track the file or the contents of the directory the absolute path points to.
If the absolute path represents a tool being used it probably makes sense to track the tool version as an input instead.

If you are adding conditional logic whether you are building on CI or on a developer machine make sure that this does not break loading task outputs on developer machines from CI.
For example, the following setup would break caching of `Test` tasks, since Gradle always would detect the difference in custom task actions:

[source, groovy]
if (System.getenv().containsKey("CI") {
    test.doFirst {
            println "Running test on CI"
        }
    }
}

You should always add the action unconditionally:

[source, groovy]
test.doFirst {
    if (System.getenv().containsKey("CI") {
            println "Running test on CI"
        }
    }
}

This way, both the task has the same custom action on CI and on developer builds and its outputs can be re-used if the remaining inputs are the same.

=== Line endings

If you are building on different operating systems be aware that some version control systems convert line endings on check-out.
For example git on Windows by default uses `autocrlf=true` which converts all line endings to `\r\n`.
As a consequence, compilation outputs can't be re-used on Windows since the input sources are different.
You should make sure that `autocrlf=false` across your build machines to ensure optimal build cache usage.

=== Symbolic links

Gradle does not store the symbolic link in the build cache but the actual file contents of the destination of the link.
As a consequence you might have a hard time when trying to re-use outputs which heavily use symbolic links.
There currently is no workaround for this behavior.

=== Java version tracking

Gradle does track the major version of Java as an input for compilation and test execution.
Currently, it does neither track the vendor nor the minor version.
Still, the vendor and the minor version may influence the bytecode produced by compilation.

If you use different JVM vendors for compiling or running Java we strongly suggest that you add the vendor as an input to the corresponding tasks.
This can be achieved by using the {user-manual}more_about_tasks.html#sec:task_input_output_runtime_api[runtime API] as shown in the following snippet.

[source,groovy]
------------------
tasks.withType(AbstractCompile) {
    inputs.property("java.vendor") {
        System.getProperty("java.vendor")
    }
}

tasks.withType(Test) {
    inputs.property("java.vendor") {
        System.getProperty("java.vendor")
    }
}
------------------

With respect to tracking the Java minor version there are different competing aspects: support pulling results for developers and having "perfect" results on CI. There are basically two situations when you may want to track the minor version number of Java: compilation and for runtime.

For compilation we saw sometimes differences in the produced bytecode for different minor version numbers. The bytecode should still expose the same runtime behavior.
Note that {user-manual}java_plugin.html#sec:java_compile_avoidance[Java compile avoidance] will treat this bytecode the same since it extracts the ABI.

Treating the minor number always as an input would it make very hard for developers to pull from the build cache. We saw that even in bigger companies different developers on the same team were using different Java minor versions. If you are able to control the environment in a way that everybody in your team and on CI is using exactly the same Java minor version then we suggest that you add the minor version as an input.

Note that even without tracking the Java minor version you may have cache misses for developers due to some locally compiled class files which constitute an input to test execution.
If these outputs made it into the local build cache on this developers machine even a clean will not solve this situation.
Therefore, the choice for tracking the Java minor version is between sometimes or never re-using outputs between for test execution between different Java minor versions.

Note that the compiler infrastructure provided by the JVM used to run Gradle is also used by the Groovy compiler.
Therefore, you can expect differences in the bytecode of compiled Groovy classes for the same reasons as above and the same suggestions apply.

=== Avoid changing inputs external to your build

If your build is dependent on external dependencies like binary artifacts or dynamic data from a web page you need to make sure that these inputs are consistent throughout your infrastructure.
When there are some variations between machines then there will be no cache hits.

Never re-release a non-changing binary dependency with the same version number but different contents: if this happens with a plugin dependency, you will never be able to explain why you don’t see cache reuse between machines (it’s because they have different versions of that artifact).

For changing binary dependencies you would need to pay attention whether the same dependency is used throughout your build pipeline.
You may want to look into the https://github.com/nebula-plugins/gradle-dependency-lock-plugin[dependency lock plugin] or switch to using {user-manual}composite_builds.html[composite builds] instead.

The same is true for depending on volatile external resources, for example a list of released versions.
One way of locking the changes would be to check in the volatile resource whenever it changes so that the builds only depend on the state in source control and not on the volatile resource itself.

=== Suggestions for authoring your build

==== Review usages of `doFirst`

Using `doFirst` from a build script on a cacheable tasks ties you to build script changes since the implementation of the closure comes from the build script.
If possible, you should use a separate tasks instead.

Modifying inputs or output properties via the runtime API in `doFirst` is discouraged since these changes will not be detected for up-to-date checks and the build cache.
Even worse, when the task does not execute then the configuration of the task is actually different from when it executes.
Instead of using `doFirst` for modifying the inputs consider using a separate tasks to configure the task under question - a so called configure task.
E.g., instead of doing

[source,groovy]
jar {
    doFirst {
        jar.manifest.mainAttributes('Class-Path': "${project(':core').jar.archivePath.name} ${project(':baseServices').jar.archivePath.name}")
    }
}

do

[source,groovy]
-------------------
task configureJar {
    doLast {
        jar.manifest.mainAttributes('Class-Path': "${project(':core').jar.archivePath.name} ${project(':baseServices').jar.archivePath.name}")
    }
}

jar.dependsOn(configureJar)
-------------------

==== Build logic based on the outcome of a task

Do not base build logic on whether a task has been _executed_.
In particular you should not assume that the output of a task can only change if it did actually execute.
The outputs could have been loaded from the build cache, too.
In general, you should work together Gradle's up-to-date checks since this will ensure that task output caching has the same view of the task.
Using `outputs.upToDateWhen` is discouraged and should be better modelled by adding the right inputs to the task.

==== No overlapping outputs

If two tasks write to the same output directory or output file they cannot be cached and task output caching will be automatically disabled for the task.
Gradle's built-in tasks are configured in a way that there will not be any overlapping outputs.
When you add new tasks to your build or re-configure built-in tasks make sure you do not create overlapping outputs for cacheable tasks.
If you must you can add a `Sync` task which then would sync the merged outputs into the target directory while the original tasks remain cacheable.
