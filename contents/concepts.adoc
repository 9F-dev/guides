== Important concepts

As we said before, how much of your build gets loaded from cache depends on many factors. In this section we'll review some of the tools that are essential for well-cached builds.

[[concepts_repeatable_task_outputs]]
=== Repeatable task outputs

Imagine that you've just pulled the main branch of your software afresh from version control. CI has already built this particular commit, so the remote cache should be hot: if you ran a build now, every cacheable task would be loaded from cache.

Consider now making a small change to the inputs of your code generator task. Let's make this a change that will not result in any _meaningful_ difference to the code-generator. Maybe add an empty line at the end of a file, or change a comment.

Because you've changed its inputs, the code generator task needs to execute again during the next build. However, it will generate _exactly the same output_ as before, so anything that depends on that output will stay up-to-date.

On the other hand, your code generator might add some extra information to its output that doesn't depend on its declared inputs, like a timestamp. In such a case the otherwise unimportant change to the code generator's inputs _will_ result in different code being generated (because the timestamp will be updated). Tasks that depend on the code generator's output will need to be re-executed.

The key here is not to depend on undeclared volatile inputs like the aforementioned timestamps, or sequences like a CI build number.

[[stable_task_inputs]]
=== Stable task inputs

Having a task repeatably produce the same output is not enough if its inputs keep changing all the time.
Such unstable inputs can be supplied directly to the task. Think of a version number that includes a timestamp being added to the jar file's manifest:

[source,groovy]
----
version = "3.2-${System.currentTimeMillis()}"

jar {
    manifest {
        attributes("Implementation-Version": version)
    }
}
----

Another example for unstable inputs is the commit ID from version control.
Maybe your version number is generated via `git describe` (and you include it in the jar manifest as shown above).
Or maybe you include the commit hash directly in `version.properties` or a JAR manifest attribute.
Either way, the outputs produced by any tasks depending on such data will only be re-usable by builds running against the exact same commit.

Tasks are rarely work in a standalone fashion, and instead frequently depend on each other's outputs.
A task using the non-repeatable outputs of another task as its inputs is a frequent way to introduce unstable inputs, too.

[[normalization]]
=== Better re-use via input normalization

We saw that having stable inputs is crucial for cacheable tasks.
However, achieving byte by byte identical inputs for each task can be challenging.
In some cases sanitizing the output of a task to remove unnecessary information can be a good approach, but this also means that a task's output can only be normalized for a single purpose.

This is where {user-manual}more_about_tasks.html#sec:configure_input_normalization[input normalization] comes into play.
Input normalization is used by Gradle to determine if two task inputs are _essentially_ the same.
Gradle uses normalized inputs when doing up-to-date checks and when determining if a cached result can be re-used instead of executing the task.
As input normalization is declared by the task _consuming_ the data as input, different tasks can define different ways to normalize the same data.

When it comes to file inputs, Gradle can normalize the path of the files as well as their contents.

[[relocatability]]
==== Path sensitivity and relocatability

When sharing cached results between computers, it's rare that everyone runs the build from the exact same location on their computers.
To allow cached results to be shared even when builds are executed from different root directories, Gradle needs to understand which inputs can be relocated and which cannot.

Tasks having files as inputs can declare the parts of a file's path what are essential to them: this is called the _path sensitivity_ of the input.
Task properties declared with `ABSOLUTE` path sensitivity are considered non-relocatable.
This is the default for properties not declaring path sensitivity, too.

For example, the class files produced by the Java compiler are dependent on the file names of the Java source files: renaming the source files with public classes would fail the build.
However, moving the files around would have no effect on the result of the compilation.
Therefore, the path sensitivity for the sources of the `JavaCompile` task is `NAME_ONLY`. Because of this only the normalized paths of the Java source files -- the file names -- are considered as inputs to the `JavaCompile` task.

==== Content normalization

[[compile_avoidance]]
===== Compile avoidance for Java

When it comes to the dependencies of a `JavaCompile` task (i.e. its _compile classpath),_ only changes to the Application Binary Interface (ABI) of these dependencies require compilation to be executed.
Gradle has a deep understanding of what a compile classpath is and uses a sophisticated normalization strategy for it.
Task outputs can be re-used as long the the ABI of the classes on the compile classpath stays the same.
This enables Gradle to avoid Java compilation by using incremental builds, or load results from the cache that were produced by different (but ABI-compatible) versions of dependencies.
For more information on compile avoidance see the corresponding section in the {user-manual}java_plugin.html#sec:java_compile_avoidance[user guide].

[[runtime_classpath]]
===== Runtime classpath normalization

Similar to compile avoidance, Gradle does understand the concept of a runtime classpath, and uses tailored input normalization to avoid running e.g. tests.
For runtime classpaths Gradle inspects the contents of jar files and ignores the timestamps and order of the entries in the jar file.
This means that a rebuilt jar file would be considered the same runtime classpath input.
For details on what level of understanding Gradle has for detecting changes to classpaths see the {user-manual}more_about_tasks.html#sec:task_input_using_classpath_annotations[userguide].

[[filter_runtime_classpath]]
====== Filtering runtime classpaths

For a runtime classpath it is possible to provide better insights to Gradle which files are essential to the input by {user-manual}more_about_tasks.html#sec:configure_input_normalization[configuring input normalization].

Let's say you want to add a file `build-info.properties` to all your produced jar files which contains volatile information about the build, e.g. the timestamp when the build started or some ID to identify the CI job that published the artifact.
This file is only used for auditing purposes, and has no effect on the outcome of running tests.
Nonetheless, this file is part of the runtime classpath for the `test` task. Since the file changes on every build invocation, tests cannot be cached effectively.
To fix this you can ignore `build-info.properties` on any runtime classpath by adding the following configuration to build script:

[source,groovy]
----
normalization {
    runtimeClasspath {
        ignore "build-info.properties"
    }
}
----

The effect of this configuration would be that changes to `build-info.properties` would be ignored for both up-to-date checks and task output caching.
This will not change the runtime behavior of the `test` task -- i.e. any test is still able to load `build-info.properties`, and the runtime classpath stays the same as before.

[[concepts_overlapping_outputs]]
=== The case against overlapping outputs

When two tasks write to the same output directory or output file, it is difficult for Gradle to determine which output belongs to which task.
There are many edge cases, and executing the tasks in parallel cannot be done safely.
It is also hard to automatically remove stale output files for the same reason.
Tasks that have dedicated, non-overlapping outputs can always be handled in a safe fashion by Gradle.
For the aforementioned reasons, task output caching is automatically disabled for tasks whose output directories overlap with another task.
Removing any overlapping outputs is important for good caching performance.

Gradle Enterprise will show tasks where caching was disabled for overlapping outputs in the timeline:

image::overlapping-outputs-timeline.png[]

=== Re-use of outputs between different tasks

Some builds exhibit a surprising characteristic: even when executed against an empty cache, they produce tasks loaded from cache. How is this possible? Rest assured that this is completely normal.

When considering task outputs, Gradle only cares about the inputs to the task: the task type itself, input files and parameters etc., but it doesn't care about the task's name or which project it can be found in.
Running `javac` will produce the same output regardless of the name of the `JavaCompile` task that invoked it.
If your build includes two tasks that share every input, the one executing later will be able to re-use the output produced by the first.

Having two tasks in the same build that do the same might sound like a problem to fix, but it is not necessarily something bad.
For example, the Android plugin creates several tasks for each variant of the project; some of those tasks will potentially do the same thing.
These tasks can safely re-use each other's outputs.

=== Non-cacheable tasks

We've been talking quite a bit about cacheable tasks, which implies there are non-cacheable ones, too. If caching task outputs is as awesome as it sounds, why not cache every task?

There are tasks that are definitely worth caching: tasks that do complex, repeatable processing and produce moderate amounts of output. Compilation tasks are usually ideal candidates for caching. At the other end of the spectrum lie I/O-heavy tasks, like `Copy` and `Sync`. Moving files around locally typically cannot be sped up by copying them from a cache. If we did so, we would even waste good resources on storing all those redundant results in the cache.

Most tasks are either obviously worth caching, or obviously not. For those in-between a good rule of thumb is to see if downloading results would be significantly faster than producing them locally.
