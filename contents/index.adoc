= Using the Worker API

The Worker API provides the ability to break up the execution of a task action into discrete units of work
and then to execute that work concurrently and asynchronously.  This allows Gradle to fully utilizes the
resources available and complete builds faster.  This guide will walk you through the process of converting
an existing custom task to use the Worker API.

This guide assumes that you understand the basics of writing Gradle custom tasks.  Please consider working
through {guides}/writing-gradle-tasks[Writing Gradle Tasks] first.

== What you'll create

You'll start by creating a custom task class that generates MD5 hashes for a configurable set of files.  Then,
you'll convert this custom task to use the Worker API.  Then we'll explore running the task with different levels of
isolation.  In the process, you'll learn about the basics of the Worker API and the capabilities it provides.

== What you'll need

* About +++<span class="time-to-complete-text"></span>+++
* A text editor or IDE
* A Java Development Kit (JDK), version 1.7 or better
* A https://gradle.org/install[Gradle distribution], version {gradle-version} or better

== Create a custom task class

First, you'll need to create a custom task that generates MD5 hashes of a configurable set of files.

In a new directory, create a `buildSrc/build.gradle` file.

.buildSrc/build.gradle
[source,groovy]
----
repositories {
    mavenCentral()
}

dependencies {
    compile "commons-codec:commons-codec:1.9" // <1>
}
----
<1> Our custom task class will use https://commons.apache.org/proper/commons-codec/[Apache Commons Codec] to generate
MD5 hashes.

TIP: If you are not familiar with `buildSrc`, this is a special directory that allows you to define and build
custom classes that should be available for use in your build script.  See
{user-manual}organizing_build_logic.html#sec:build_sources[the user manual] for further information.


Now, create a custom task class in our `buildSrc/src/main/groovy` directory.  You should name this class `CreateMD5`.

.buildSrc/src/main/groovy/CreateMD5.groovy
[source,groovy]
----
import org.apache.commons.codec.digest.DigestUtils
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.SourceTask
import org.gradle.api.tasks.TaskAction

class CreateMD5 extends SourceTask { // <1>
    @OutputDirectory
    File destinationDir // <2>

    @TaskAction
    void createHashes() {
        source.files.each { File sourceFile -> // <3>
            sourceFile.withInputStream { InputStream stream ->
                println "Generating MD5 for ${sourceFile.name}..."
                new File(destinationDir, "${sourceFile.name}.md5").text = DigestUtils.md5Hex(stream) // <4>
            }
        }
    }
}
----
<1> {api-reference}org/gradle/api/tasks/SourceTask.html[SourceTask] is a convenience type for tasks that operate on a
set of source files.
<2> The output of the task will go into a configured directory.
<3> The task iterates over all of the files defined as "source files" and creates an MD5 has of each.
<4> The MD5 hash of each file is written to the output directory into a file of the same name with an "md5" extension.

Next, create a build.gradle that implements your new `CreateMD5` task.

.build.gradle
[source,groovy]
----
plugins { id 'base' } // <1>

task md5(type: CreateMD5) {
    outputDir = "${buildSrc}/md5" // <2>
    source file("src") // <3>
}
----
<1> Apply the `base` plugin so that you'll have a `clean` task to use to remove the output.
<2> MD5 hash files will be written to `build/md5`.
<3> This task will generate MD5 hash files for every file in the `src` directory.

Now, you'll need some source to generate MD5 hashes from.  Create 3 files in the src directory:

.src/einstein.txt
[source,text]
----
Intellectual growth should commence at birth and cease only at death.
----

.src/feynman.txt
[source,text]
----
I was born not knowing and have had only a little time to change that here and there.
----

.src/oppenheimer.txt
[source,text]
----
No man should escape our universities without knowing how little he knows.
----

At this point, you can give your task a try:

[listing]
----
$ gradle md5
----

You should see output similar to:

[listing]
----
> Task :md5
Generating MD5 for einstein.txt...
Generating MD5 for feynman.txt...
Generating MD5 for oppenheimer.txt...


BUILD SUCCESSFUL in 0s
----

In the `build/md5` directory, you should now see corresponding files with an `md5` extension containing MD5 hashes of the
files from the src directory.

== Converting to the Worker API

One issue with this task is that it processes each file in sequence.  However, the processing of each file is
independent of any other file.  It would be really nice if this work was done in parallel and could take advantage
of multiple processors.  This is where the Worker API can help.

First, you'll need to refactor the part of our custom task that does the work for each individual file into a separate
class.  This class is our "unit of work" implementation and should implement `java.lang.Runnable`.

.buildSrc/src/main/groovy/GenerateMD5.groovy
[source,groovy]
----
import javax.inject.Inject
import org.apache.commons.codec.digest.DigestUtils

class GenerateMD5 implements Runnable {
    File sourceFile
    File md5File

    @Inject // <1>
    public GenerateMD5(File sourceFile, File md5File) { // <2>
        this.sourceFile = sourceFile
        this.md5File = md5File
    }

    @Override
    public void run() {
        println "Generating MD5 for ${sourceFile.name}..."
        sourceFile.withInputStream { stream ->
            md5File.text = DigestUtils.md5Hex(stream)
        }
    }
}
----
<1> This class must have a constructor annotated `javax.inject.Inject`.
<2> The parameters to the constructor are the parameters of the individual unit of work.

Now, you should change your custom task class to submit work to the
{language-reference}org.gradle.workers.WorkerExecutor.html[WorkerExecutor] instead of doing the work itself.

.buildSrc/src/main/groovy/CreateMD5.groovy
[source,groovy]
----
import javax.inject.Inject
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.SourceTask
import org.gradle.api.tasks.TaskAction
import org.gradle.workers.WorkerExecutor
import org.gradle.workers.IsolationMode

class CreateMD5 extends SourceTask {
    WorkerExecutor workerExecutor // <1>

    @OutputDirectory
    File destinationDir

    @Inject // <2>
    public CreateMD5(WorkerExecutor workerExecutor) {
        this.workerExecutor = workerExecutor
    }

    @TaskAction
    void createHashes() {
        source.files.each { File sourceFile ->
            File md5File = new File(destinationDir, "${sourceFile.name}.md5")
            workerExecutor.submit(GenerateMD5) { // <3>
                isolationMode = IsolationMode.NONE // <4>
                params = [ sourceFile, md5File ] // <5>
            }
        }
    }
}
----
<1> You'll need to have the {language-reference}org.gradle.workers.WorkerExecutor.html[WorkerExecutor] service in order
to submit your work.
<2> To get a {language-reference}org.gradle.workers.WorkerExecutor.html[WorkerExecutor], create a constructor annotated
with `javax.inject.Inject`.  Gradle will inject the
{language-reference}org.gradle.workers.WorkerExecutor.html[WorkerExecutor] at runtime when the task is created.
<3> When submitting the unit of work, specify the unit of work implementation, in this case `GenerateMD5`.
<4> For now, use an isolation mode of `NONE`.  We'll talk more about isolation modes later.
<5> For each unit of work, configure the `params` property appropriately.  These values should match up to the values
passed to the constructor of `GenerateMD5`.

At this point, you should be able to try your task again.

[listing]
----
$ gradle clean md5

> Task :md5
Generating MD5 for einstein.txt...
Generating MD5 for feynman.txt...
Generating MD5 for oppenheimer.txt...


BUILD SUCCESSFUL in 0s
----

The results should look the same as before, although the MD5 hash files may be generated in a different order due to
the fact that the units of work are executed in parallel.

== Changing the isolation mode

The isolation mode speaks to what lengths Gradle will go to isolate the items of work from each other as well as from
the rest of the Gradle runtime.  `IsolationMode.NONE` creates the minimum of isolation and shares the classloader from
the task.  This is the fastest isolation mode because it requires the least overhead to set up the work item to execute.
But what if you wanted the user to be able to configure the task to run with a different (but compatible)
version of the https://commons.apache.org/proper/commons-codec/[Apache Commons Codec] library?  The Worker API allows
you to do that, too.

First, you'll want to change the dependency in `buildSrc/build.gradle` to be `compileOnly`.  This tells Gradle that it
should use this dependency when building the classes, but should not put it on the build script classpath.

.buildSrc/build.gradle
[source, groovy]
----
repositories {
    mavenCentral()
}
dependencies {
    compileOnly "commons-codec:commons-codec:1.9"
}
----

Next, you'll want to change the `CreateMD5` task to allow the user to configure the version of the codec library that
they want to use.  It'll resolve the appropriate version of the library at runtime and configure the workers to use
this version.  The isolation mode `CLASSLOADER` tells Gradle to run this worker in a thread with an isolated
classloader.

.buildSrc/src/main/groovy/CreateMD5.groovy
[source, groovy]
----
import javax.inject.Inject
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.SourceTask
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.Input
import org.gradle.workers.WorkerExecutor
import org.gradle.workers.IsolationMode

class CreateMD5 extends SourceTask {
    WorkerExecutor workerExecutor

    @OutputDirectory
    File destinationDir

    @Input
    String codecVersion = "1.9" // <1>

    @Inject
    public CreateMD5(WorkerExecutor workerExecutor) {
        this.workerExecutor = workerExecutor
    }

    Set<File> getCodecClasspath() {
        return project.configurations.detachedConfiguration(
            project.dependencies.create("commons-codec:commons-codec:${codecVersion}") // <2>
        ).files
    }

    @TaskAction
    void createHashes() {
        source.files.each { File sourceFile ->
            File md5File = new File(destinationDir, "${sourceFile.name}.md5")
            workerExecutor.submit(GenerateMD5) {
                isolationMode = IsolationMode.CLASSLOADER
                params = [ sourceFile, md5File ]
                classpath getCodecClasspath() // <3>
            }
        }
    }


}
----
<1> Expose an input property for the codec library version with a default value.
<2> Use the `codecVersion` input property to construct and resolve a configuration to a set of files.
<3> Configure the resolved classpath on the
{language-reference}org.gradle.workers.WorkerConfiguration.html[WorkerConfiguration] when submitting the work item.

Next, you'll need to configure your build so that it has a repository to look up the codec version at task execution
time.

.build.gradle
[source,groovy]
----
plugins { id 'base' }

repositories {
    jcenter() // <1>
}

task md5(type: CreateMD5) {
    destinationDir = file("${buildDir}/md5s")
    source = file("src")
    codecVersion = "1.10" // <2>
}
----
<1> Add a repository to resolve the codec library - this can be a different repository than the one used to build the
`CreateMD5` task class.
<2> Configure an alternate, compatible version of https://commons.apache.org/proper/commons-codec/[Apache Commons Codec].

Now, if you run your task, it should work as expected using the configured version of the codec library:

[listing]
----
$ gradle clean md5

> Task :md5
Generating MD5 for einstein.txt...
Generating MD5 for feynman.txt...
Generating MD5 for oppenheimer.txt...


BUILD SUCCESSFUL in 2s
----

== Creating a Worker Daemon

Sometimes it is desirable to create even further isolation when executing items of work.  For instance, external
libraries may rely on certain system properties to be set which may conflict between work items.  Or a library might
not be compatible with the version of JDK that Gradle is running with and may need to be run with a different version.
The Worker API can accommodate this with an isolation mode of `PROCESS` that causes the work to execute in a separate
"worker daemon".

To change to a worker daemon, you can simply change the isolation mode on the work items.  You may also want to
configure custom settings for the new process.

.buildSrc/src/main/groovy/CreateMD5.groovy
[source,groovy]
----
import javax.inject.Inject
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.SourceTask
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.Input
import org.gradle.workers.WorkerExecutor
import org.gradle.workers.IsolationMode

class CreateMD5 extends SourceTask {
    WorkerExecutor workerExecutor

    @OutputDirectory
    File destinationDir

    @Input
    String codecVersion = "1.9"

    @Inject
    public CreateMD5(WorkerExecutor workerExecutor) {
        this.workerExecutor = workerExecutor
    }

    @TaskAction
    void createHashes() {
        source.files.each { File sourceFile ->
            File md5File = new File(destinationDir, "${sourceFile.name}.md5")
            workerExecutor.submit(GenerateMD5) {
                isolationMode = IsolationMode.PROCESS // <1>
                forkOptions { options ->
                    options.maxHeapSize = "64m" // <2>
                }
                params = [ sourceFile, md5File ]
                classpath getCodecClasspath()
            }
        }
    }

    Set<File> getCodecClasspath() {
        return project.configurations.detachedConfiguration(
            project.dependencies.create("commons-codec:commons-codec:${codecVersion}")
        ).files
    }
}
----
<1> Change the isolation mode to `PROCESS`.
<2> Set up the {api-reference}org/gradle/process/JavaForkOptions.html[JavaForkOptions] for the new process.

Now, you should be able to run your task, and it will work as expected but using worker processes instead:

[listing]
----
$ gradle clean md5

> Task :md5
Generating MD5 for einstein.txt...
Generating MD5 for feynman.txt...
Generating MD5 for oppenheimer.txt...


BUILD SUCCESSFUL in 2s
----

== Summary

*TBC*


include::contribute[]
