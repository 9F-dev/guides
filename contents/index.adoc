= Migrating build logic from Groovy to Kotlin
:numbered:

Kotlin and Groovy languages are very different beasts, each with its own strengths.

Kotlin is statically typed and has null safety built-int and comes with top-notch IDE tooling from auto-completion to refactoring and everything in-between.

Groovy on the other hand is highly dynamic by nature, hence very flexible but lacking proper IDE tooling.

Gradle is implemented in Java on top of the JVM.
Both the Groovy DSL and the Kotlin DSL are implemented on top of the Gradle Java API.

[NOTE]
If you want to read on Kotlin the language before getting started or if you need some reference documentation along the way, the https://kotlinlang.org/docs/reference/[reference documentation] is the place to go.
The https://kotlinlang.org/docs/tutorials/koans.html[Kotlin Koans] provide a fun way to learn Kotlin.


== Groovy meet Kotlin

Kotlin the language is statically typed and has null safety built-int.
Groovy on the other hand is highly dynamic by nature.

* Kotlin language more strict than Groovy language
* Kotlin DSL more strict than Groovy DSL

Both DSLs provide means to interact with the Gradle dynamic and extensible model, and runtime.

With the Kotlin DSL:

* more ceremony to do dynamic things, some limitations with helpers
* more safety, more tooling


Applying Gradle best practices tend towards more declarative builds, less dynamic constructs. This is where the Kotlin DSL shines with the less ceremony and the more tooling. In that sense, the Kotlin DSL encourages Gradle best practices.

Applying Gradle best practices will make it much easier with the Kotlin DSL

[TIP]
--
* link to Gradle Kotlin DSL presentation in manual
* link to Gradle best practices in manual and guides
--

== A taste at the differences

To get started we will look at the main differences between the Groovy DSL and the Kotlin DSL from a scripting point of view. You can switch from Groovy script excerpts to Kotlin ones to see the differences.

* File names
* Applying plugins
* Working with tasks
* Dependencies and configurations
* Properties
* Live collections and containers
* Extensions


## File names

To use the Kotlin DSL, simply name your files `build.gradle.kts` instead of `build.gradle`.

The `settings.gradle` file can also be renamed `settings.gradle.kts`.

In a multi-project build, you can have some modules using the Groovy DSL (and thus use `build.gradle` files), and some other modules using the Kotlin DSL (and thus use `build.gradle.kts` files). So you're not forced to migrate everything at once.

## Applying built-in plugins

Using the `plugins` block:

.Groovy
[source, groovy]
----
plugins {
    id 'java'
    id 'jacoco'
}
----

.Kotlin
[source, kotlin]
----
plugins {
    java
    id("jacoco")
}
----

As you can see with the `jacoco` example, the same syntax can be used in Groovy and Kotlin (except for double quotes and parentheses that must be used in Kotlin, of course).

But the Kotlin DSL also defines extension properties for all (AFAIK) built-in plugins, so you can use them, as shown above with the `java` example.

You can also use the older `apply` syntax:

.Groovy
[source, groovy]
----
apply plugin: 'checkstyle'
----

.Kotlin
[source, kotlin]
----
apply(plugin = "checkstyle")
----

## Applying external plugins

Using the `plugins` block:

.Groovy
[source, groovy]
----
plugins {
    id 'org.springframework.boot' version '2.0.1.RELEASE'
}
----

.Kotlin
[source, kotlin]
----
plugins {
    id("org.springframework.boot") version "2.0.1.RELEASE"
}
----

You can also use the older `apply` syntax, but then the plugin must be added to the classpath of the build script:

.Groovy
[source, groovy]
----
buildscript {
    repositories {
        gradlePluginPortal()
    }
    dependencies {
        classpath("gradle.plugin.com.boxfuse.client:gradle-plugin-publishing:5.0.3")
    }
}

apply plugin: 'org.flywaydb.flyway'
----

.Kotlin
[source, kotlin]
----
buildscript {
    repositories {
        gradlePluginPortal()
    }
    dependencies {
        classpath("gradle.plugin.com.boxfuse.client:gradle-plugin-publishing:5.0.3")
    }
}

apply(plugin = "org.flywaydb.flyway")
----

## Applying the Kotlin plugin

If you're using Kotlin to write your build scripts, you probably also use Kotlin in your project. Applying the Kotlin plugin is no different from applying any external other plugin. But the DSL has an extension function to make it shorter:

.Groovy
[source, groovy]
----
plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.2.41'
}
----

.Kotlin
[source, kotlin]
----
plugins {
    kotlin("jvm") version "1.2.41"
}
----

## Customizing an existing task

This is where Groovy and Kotlin start to differ. Since Kotlin is a statically typed language, and since you want to benefit from this static typing by discovering available properties and methods using auto-completion, you need to know and provide the type of the task you want to configure.

Here is how you can configure a single property of the existing `jar` task:

.Groovy
[source, groovy]
----
jar.archiveName = 'foo.jar'
----

.Kotlin
[source, kotlin]
----
val jar: Jar by tasks
jar.archiveName = "foo.jar"
----

Note that specifying the type of the task explicitly is necessary. Otherwise, the script won't compile because the inferred type of `jar` will be `Task`, and the `archiveName` property is specific to the `Jar` task.

You can, however, omit the type if you only need to configure properties or call methods declared in `Task`:

.Groovy
[source, groovy]
----
test.doLast {
    println("test completed")
}
----

.Kotlin
[source, kotlin]
----
val test by tasks
test.doLast { println("test completed") }
----

If you need to configure several properties or call multiple methods on the same task you can group them in a block as follows:

.Groovy
[source, groovy]
----
jar {
    archiveName = 'foo.jar'
    into('META-INF') {
        from('bar')
    }
}
----

.Kotlin
[source, kotlin]
----
val jar by tasks.getting(Jar::class) {
    archiveName = "foo.jar"
    into("META-INF") {
        from("bar")
    }
}
----

If you already have a `val` for the task you want to configure in scope, the Kotlin `apply` function is handy:

.Kotlin
[source, kotlin]
----
val jar: Jar by tasks
jar.apply {
    archiveName = "foo.jar"
    into("META-INF") {
        from("bar")
    }
}
----

But there is another idiomatic way to configure tasks: using a `tasks` block:

.Groovy
[source, groovy]
----
jar {
    archiveName = 'foo.jar'
    into('META-INF') {
        from('bar')
    }
}

test.doLast {
    println("test completed")
}
----

.Kotlin
[source, kotlin]
----
tasks {
    "jar"(Jar::class) {
        archiveName = "foo.jar"
        into("META-INF") {
            from("bar")
        }
    }

    "test" {
        doLast { println("test completed") }
    }
}
----

Once again, note that if you need to apply task-specific configurations, you need to provide the type of the task (`Jar` in this example).

This means that you'll sometimes need to dive in the documentation or source code of custom plugins to discover what the types of its custom tasks are, and to import them, or use their fully qualified name.

.Groovy
[source, groovy]
----
plugins {
    id('java')
    id 'org.springframework.boot' version '2.0.1.RELEASE'
}

repositories {
    mavenCentral()
}

apply plugin: 'io.spring.dependency-management'

bootJar {
    archiveName = 'app.jar'
    mainClassName = 'com.ninja_squad.demo.Demo'
}

bootRun {
    main = 'com.ninja_squad.demo.Demo'
    args '--spring.profiles.active=demo'
}
----

.Kotlin
[source, kotlin]
----
import org.springframework.boot.gradle.tasks.bundling.BootJar
import org.springframework.boot.gradle.tasks.run.BootRun

plugins {
    java
    id("org.springframework.boot") version "2.0.1.RELEASE"
}

repositories {
    mavenCentral()
}

apply(plugin = "io.spring.dependency-management")

tasks {
    "bootJar"(BootJar::class) {
        archiveName = "app.jar"
        mainClassName = "com.ninja_squad.demo.Demo"
    }

    "bootRun"(BootRun::class) {
        main = "com.ninja_squad.demo.Demo"
        args("--spring.profiles.active=demo")
    }
}
----

## Creating a task

Creating a task can be done by declaring delegated property, delegating to `tasks.creating`:

.Groovy
[source, groovy]
----
task greeting {
    println('always printed: configuration phase')
    doLast {
        println('only printed if executed: execution phase')
    }
}
----

.Kotlin
[source, kotlin]
----
val greeting by tasks.creating {
    println("always printed: configuration phase")
    doLast {
        println("only printed if executed: execution phase")
    }
}
----

Sometimes you want to create a task of a given type (`Zip` in this example):

.Groovy
[source, groovy]
----
task docZip(type: Zip) {
    archiveName = 'doc.zip'
    from 'doc'
}
----

.Kotlin
[source, kotlin]
----
val docZip by tasks.creating(Zip::class) {
    archiveName = "doc.zip"
    from("doc")
}
----

The same things can also be done using the `tasks` block:

.Groovy
[source, groovy]
----
task greeting2 {
    println('always printed: configuration phase')
    doLast {
        println('only printed if executed: execution phase')
    }
}

task docZip2(type: Zip) {
    archiveName = 'doc.zip'
    from 'doc'
}
----

.Kotlin
[source, kotlin]
----
tasks {
    "greeting2" {
        println("always printed: configuration phase")
        doLast {
            println("only printed if executed: execution phase")
        }
    }

    "docZip2"(Zip::class) {
        archiveName = "doc2.zip"
        from("doc")
    }
}
----

Notice that creating a task uses the exact same syntax as customizing an existing task. This can be confusing, and even lead to bugs: your intention might be to customize an existing task, but if you use the wrong task name, you will end up creating a new task rather than customizing the existing task. The reader might also not know if your intention is to customize an existing task, or to create a new one. For these two reasons, you might prefer using these slightly more verbose variants, which clearly show your intent and avoid the previously described bug:

.Kotlin
[source, kotlin]
----
tasks {
    // get and customize the existing task named test. Fails if there is no test task.
    val test by getting {
        doLast { println("test completed") }
    }

    // create a new docZip3 task. Fails if a task docZip3 already exists.
    val docZip3 by creating(Zip::class) {
        archiveName = "doc3.zip"
        from("doc")
    }
}
----

## Dependencies

Declaring dependencies in the existing Java configurations is not much different from doing it in Groovy:

.Groovy
[source, groovy]
----
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'io.jsonwebtoken:jjwt:0.9.0'
    runtimeOnly 'org.postgresql:postgresql'
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude(module: 'junit')
    }
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}
----

.Kotlin
[source, kotlin]
----
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("io.jsonwebtoken:jjwt:0.9.0")
    runtimeOnly("org.postgresql:postgresql")
    testImplementation("org.springframework.boot:spring-boot-starter-test") {
        exclude(module = "junit")
    }
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}
----

## Custom configurations

Sometimes you need to add your own configuration, and add dependencies to that configuration:

.Groovy
[source, groovy]
----
configurations {
    db
    integTestImplementation {
        extendsFrom testImplementation
    }
}

dependencies {
    db 'org.postgresql:postgresql'
    integTestImplementation 'com.ninja-squad:DbSetup:2.1.0'
}
----

.Kotlin
[source, kotlin]
----
val db by configurations.creating
val integTestImplementation by configurations.creating {
    extendsFrom(configurations["testImplementation"])
}

dependencies {
    db("org.postgresql:postgresql")
    integTestImplementation("com.ninja-squad:DbSetup:2.1.0")
}
----

Note that, in the above example, you can only use `db(...)` and `integTestImplementation(...)` because they're both declared as properties before. If they were defined elsewhere, you could get them by delegating to `configurations`, or you could use a string to add a dependency to the configuration:

.Kotlin
[source, kotlin]
----
// get the existing testRuntimeOnly configuration
val testRuntimeOnly by configurations

dependencies {
    testRuntimeOnly("org.postgresql:postgresql")
    "db"("org.postgresql:postgresql")
    "integTestImplementation"("com.ninja-squad:DbSetup:2.1.0")
}
----

## Extensions

Many plugins come with extensions to configure them. If those plugins are applied using the `plugins` block (which is true for the jacoco and the Spring Boot plugins in the following example), then Kotlin extension functions are made available to configure their extension, the same way as in Groovy.

On the other hand, if you use the older `apply` function to apply a plugin (which is true for the checkstyle plugin in the following example), you'll have to use the `configure<T> {}` function to configure them:

.Groovy
[source, groovy]
----
jacoco {
    toolVersion = "0.8.1"
}

springBoot {
    buildInfo {
        properties {
            time = null
        }
    }
}

checkstyle {
    maxErrors = 10
}
----

.Kotlin
[source, kotlin]
----
jacoco {
    toolVersion = "0.8.1"
}

springBoot {
    buildInfo {
        properties {
            time = null
        }
    }
}

configure<CheckstyleExtension> {
    maxErrors = 10
}
----

[TIP]
The Gradle link:{user-manual}[user manual] and link:{guides}[guides] contain build script excerpts that demonstrate both the Groovy DSL and the Kotlin DSL.
This is the best place where to find how to do this and what with the Kotlin DSL ; and it covers all Gradle features from link:#TODO[using plugins] to link:#TODO[customizing the dependency resolution behavior].


=== Going from dynamic to static

Gradle core provides the base building blocks of the build model.
Both build and plugins authors interact with that build model through scripts and plugins.
Those interactions include contributing to the build model - e.g. adding configurations, tasks or extensions - and configuring elements of the build model - again, configurations, tasks, extensions etc…

The Gradle Java API allows build and plugin authors to interact with the build model using any JVM language. When using the Java API you need to query the model for elements contributed by plugins, mostly either by name, type or both.

On top of the Gradle Java API, the Gradle DSLs provide a more concise syntax.

Let’s look at an example. Let’s say we create a Gradle plugin implemented in Java that applies the `distribution` plugin then creates a `samples` distribution and declare its conventional content:

[source.java]
----
public class MyPlugin implements Plugin<Project> {
   @Override
   public void apply(final Project project) {

        project.getPlugins().apply("distribution");

        ExtensionContainer extensions = project.getExtensions();
        DistributionContainer distributions = extensions.getByType(DistributionContainer.class);
        Distribution samples = distributions.create("samples");
        samples.getContents().from(project.getLayout().getProjectDirectory().dir("src/samples"));
   }
}
----

It's verbose, but let not focus on that.

The `distribution` plugin contributes an extension to the project model named `distributions` and of type `DistributionContainer`.
The sample above queries the project model for that extension by type and then use it.
It could also have queried for the extension by name with `project.getExtensions().getByName("distributions")` but a cast to `DistributionContainer` would have been needed before interacting with it. In other words, models contributed by plugins are addressed by name, type or both.
That's a lot of ceremony.

The main goal of both Gradle DSLs is to reduce that ceremony. In both DSLs this is achieved by using a concise programming language, syntactic helpers plus constructs that make it easier to work with the Gradle extensible model.

Let's now look at the very same intent but implemented using the Groovy DSL,

[source, groovy]
----
plugins {
    id 'distribution'
}
distributions {
    samples {
        contents {
            from layout.projectDirectory.dir('src/samples')
        }
    }
}
----

and the Kotlin DSL:

[source, kotlin]
----
plugins {
    id("distribution")
}
distributions {
    create("samples") {
        contents {
            from(layout.projectDirectory.dir("src/samples"))
        }
    }
}
----

In both scripts above, the `distributions` extension of type `DistributionContainer` contributed by the `distribution` plugin is simply called out by name.
Both DSLs provide constructs to address model elements contributed by plugins.

In both scripts above, the `samples` distribution is created and configured on the `distributions` extension which is a link:{user-manual}custom_plugins.html#sec:maintaining_multiple_domain_objects[collection of objects] for which both the Groovy DSL and the Kotlin DSL provide syntactic helpers.

There are some differences, but the concerns are the same.

// TODO explain what happens in each case to make things very clear


== Migration strategies

Both scripts using the Kotlin DSL, `\*.gradle.kts`, and scripts using the Groovy DSL, `*.gradle`, can participate in the same build. Gradle plugins implemented in `./buildSrc`, an included build or externally fetched can use any JVM language. This makes it possible to migrate progressively, piece by piece, without blocking your team.

// TODO define/link "constraints", should be present in the user manual

Mechanical migration vs. restructuring towards best practices:

* both possible
* the former will be enough for simple builds
* a complex and highly dynamic build logic will require some restructuring
* external plugins might not provide a good Kotlin DSL experience, workarounds

[NOTE]
--
Depending on your build structure you might be interested by the following samples built with the Kotlin DSL:

* link to modularity sample
* link to multi-project samples
* link to gradle-plugin sample
* link to composite-builds sample
* link to source-control sample
--

Refactor towards the use of the `plugins {}` block using `pluginManagement {}` in `settings.gradle.kts` to control plugin resolution.

Refactor towards the use of `buildSrc` using the `kotlin-dsl` plugin.
// and pre-compiled scripts `buildSrc/src/main/kotlin/my-plugin.gradle.kts`


== Call Java or Groovy from Kotlin

* https://kotlinlang.org/docs/reference/java-interop.html[Calling Java from Kotlin]
* https://github.com/gradle/kotlin-dsl/blob/master/doc/getting-started/Closures.md[Invoking methods taking Groovy Closures] and the https://github.com/gradle/kotlin-dsl/tree/master/samples/groovy-interop[groovy-interop] sample
* `withGroovyBuilder {}` and the https://github.com/gradle/kotlin-dsl/tree/master/samples/maven-plugin[maven-plugin] sample


== Call Kotlin from Java or Groovy

* https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html[Calling Kotlin from Java]
* To call a Kotlin extension function from Groovy, call it as a static function passing the receiver as the first parameter.
* One can’t use kotlin functions with default parameters from groovy, one has to pass all parameters.


== Summary

*TBC*


include::contribute[]
