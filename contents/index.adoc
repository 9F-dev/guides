= Building Java 9 Modules

== What you'll learn

One of the most exciting features of Java 9 is its support for developing and
deploying modular Java software. In this guide, you'll learn exactly what you
need to change in your Java application to:

* produce Java 9 modules for your java libraries.
* consume Java 9 modules as your dependencies.
* use Java's `ServiceLoader` pattern with Java 9 modules.
* run an application using Java 9 modules.
* distribute your application as an optimized Java 9 runtime image.

While Gradle version {gradle-version} doesn't have first-class support for
Java 9 modules, this guide shows you how to experiment with them before that
support is added.

== What you'll need

* About +++<span class="time-to-complete-text">30 minutes</span>+++
* A text editor
* A command prompt
* The Java Development Kit (JDK), version 1.9 (build 170) or newer
* A https://gradle.org/install[Gradle distribution], version {gradle-version}
  or newer

== Understanding the Example Project

This guide explains step-by-step how to convert an example Java application
which doesn't use any Java 9 features into a fully-modular Java 9 application.
The source code for the original version of the application lives in the
`src/0-original` directory. It is organized as multi-project Gradle build made
up of six subprojects:

* `fairy` - The entry point to the storyteller java application.
* `tale` - A library which defines the public `Tale` interface.
* `formula` - A library which makes it easy to weave a `Tale`.
* `actors` - A library which represents the characters in a fairy tale.
* `pigs` - A library which produces an instance of `Tale` which represents the
  story of the three little pigs.
* `bears` - A library which produces an instance of `Tale` which represents the
  story of Goldilocks and the three bears.

The project hierarchy showing the dependency relationships between the six
projects can be seen in the following illustration:

.Project Graph
[#fig-1]
[caption="Figure 1: "]
image::project-graph.png[Project Graph]

You can clone the project and run the original program to see it's output:

[listing]
----
$ git clone git@github.com:gradle-guides/building-java-9-modules
$ cd building-java-9-modules/src/0-original
$ ./gradlew run

> Task :fairy:run
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

<... elided ...>

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.


BUILD SUCCESSFUL
----

Before you start modifying this project to have it use Java 9 modules, you need
to understand two important details of how the project is structured. Namely,
that it uses the
https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html[ServiceLoader]
api to load the fairy tales at runtime, and that it contains a test class that
shows how software modularity was broken before Java 9.

=== ServiceLoader usage
Java 1.6 introduced a simple mechanism for binding a set of implementations of
some interface (the "Service") to a consuming class at runtime. Oracle's
https://docs.oracle.com/javase/tutorial/ext/basics/spi.html[tutorial] on the
topic is a bit lengthy, but here's how it is used in our sample application:

.fairy/src/main/java/org/gradle/fairy/app/StoryTeller.java
[source,java]
----
include::{originaldir}/fairy/src/main/java/org/gradle/fairy/app/StoryTeller.java[tags=main]
----

The `ServiceLoader` coordinates with the JVM's ClassLoader to find instances of
the `Tale` class which have been specified in special files named
`org.gradle.fairy.tale.Tale` in `META-INF/services` folders on the classpath.

.bears/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale
[source,java]
----
include::{originaldir}/bears/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale[]
----

.pigs/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale
[source,java]
----
include::{originaldir}/pigs/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale[]
----

Loading these instances at runtime gives the `StoryTeller` class the loosest
possible coupling to the two libraries which implement the `Tale` interface.
You can see this in the `dependencies` block of the `build.gradle` file for the
application.

.fairy/build.gradle
[source,groovy]
----
include::{originaldir}/fairy/build.gradle[tags=deps]
----

In fact, comment out both of the lines that start, `runtimeOnly` and notice how
the output of the `run` task changes:

[listing]
----
$ ./gradlew run

> Task :fairy:run
Alas, I have no tales to tell!


BUILD SUCCESSFUL
----

=== ModularityTest discussion

== Adding `module-info.java` to your source code


== Step 2


== Step N


== Summary
