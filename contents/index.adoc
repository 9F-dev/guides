= Migrating build logic from Groovy to Kotlin
:numbered:

Kotlin and Groovy languages are very different beasts, each with its own strengths.

Kotlin is statically typed and has null safety built-int and comes with top-notch IDE tooling from auto-completion to refactoring and everything in-between.

Groovy on the other hand is highly dynamic by nature, hence very flexible but lacking proper IDE tooling.

Gradle is implemented in Java on top of the JVM.
Both the Groovy DSL and the Kotlin DSL are implemented on top of the Gradle Java API.

[NOTE]
If you want to read on Kotlin the language before getting started or if you need some reference documentation along the way, the https://kotlinlang.org/docs/reference/[reference documentation] is the place to go.
The https://kotlinlang.org/docs/tutorials/koans.html[Kotlin Koans] provide a fun way to learn Kotlin.


== Groovy meet Kotlin

Kotlin the language is statically typed and has null safety built-int.
Groovy on the other hand is highly dynamic by nature.

* Kotlin language more strict than Groovy language
* Kotlin DSL more strict than Groovy DSL

Both DSLs provide means to interact with the Gradle dynamic and extensible model, and runtime.

With the Kotlin DSL:

* more ceremony to do dynamic things, some limitations with helpers
* more safety, more tooling


Applying Gradle best practices tend towards more declarative builds, less dynamic constructs. This is where the Kotlin DSL shines with the less ceremony and the more tooling. In that sense, the Kotlin DSL encourages Gradle best practices.

Applying Gradle best practices will make it much easier with the Kotlin DSL

[TIP]
--
* link to Gradle Kotlin DSL presentation in manual
* link to Gradle best practices in manual and guides
--

== A taste at the differences

To get started we will look at the main differences between the Groovy DSL and the Kotlin DSL from a scripting point of view. You can switch from Groovy script excerpts to Kotlin ones to see the differences.

* File names
* Applying plugins
* Working with tasks
* Dependencies and configurations
* Properties
* Live collections and containers
* Extensions


=== Script file names

[NOTE]
--
Groovy DSL script files are all named `*.gradle`.

Kotlin DSL script files are all named `*.gradle.kts`.
--

To use the Kotlin DSL, simply name your files `build.gradle.kts` instead of `build.gradle`.

The `settings.gradle` file can also be renamed `settings.gradle.kts`.

In a multi-project build, you can have some modules using the Groovy DSL (and thus use `build.gradle` files), and some other modules using the Kotlin DSL (and thus use `build.gradle.kts` files). So you're not forced to migrate everything at once.

// TODO develop on other naming conventions for better IDE support


=== Applying core plugins

Using the `plugins` block:

[source.multi-language-sample, groovy]
----
plugins {
    id 'java'
    id 'jacoco'
}
----

[source.multi-language-sample, kotlin]
----
plugins {
    java
    id("jacoco")
}
----

As you can see with the `jacoco` example, the same syntax can be used in Groovy and Kotlin (except for double quotes and parentheses that must be used in Kotlin, of course).

But the Kotlin DSL also defines extension properties for all core Gradle plugins, so you can use them, as shown above with the `java` example.

You can also use the older `apply` syntax:

[source.multi-language-sample, groovy]
----
apply plugin: 'checkstyle'
----

[source.multi-language-sample, kotlin]
----
apply(plugin = "checkstyle")
----

=== Applying external plugins

Using the `plugins` block:

[source.multi-language-sample, groovy]
----
plugins {
    id 'org.springframework.boot' version '2.0.1.RELEASE'
}
----

[source.multi-language-sample, kotlin]
----
plugins {
    id("org.springframework.boot") version "2.0.1.RELEASE"
}
----

You can also use the older `apply` syntax, but then the plugin must be added to the classpath of the build script:

[source.multi-language-sample, groovy]
----
buildscript {
    repositories {
        gradlePluginPortal()
    }
    dependencies {
        classpath("gradle.plugin.com.boxfuse.client:gradle-plugin-publishing:5.0.3")
    }
}

apply plugin: 'org.flywaydb.flyway'
----

[source.multi-language-sample, kotlin]
----
buildscript {
    repositories {
        gradlePluginPortal()
    }
    dependencies {
        classpath("gradle.plugin.com.boxfuse.client:gradle-plugin-publishing:5.0.3")
    }
}

apply(plugin = "org.flywaydb.flyway")
----


=== Configuring tasks

This is where Groovy and Kotlin start to differ. Since Kotlin is a statically typed language, and since you want to benefit from this static typing by discovering available properties and methods using auto-completion, you need to know and provide the type of the task you want to configure.

Here is how you can configure a single property of the existing `jar` task:

[source.multi-language-sample, groovy]
----
jar.archiveName = 'foo.jar'
----

[source.multi-language-sample, kotlin]
----
tasks.getByName<Jar>("jar").archiveName = "foo.jar"
----

Note that specifying the type of the task explicitly is necessary. Otherwise, the script won't compile because the inferred type of `jar` will be `Task`, and the `archiveName` property is specific to the `Jar` task type.

You can, however, omit the type if you only need to configure properties or call methods declared in `Task`:

[source.multi-language-sample, groovy]
----
test.doLast {
    println("test completed")
}
----

[source.multi-language-sample, kotlin]
----
tasks["test"].doLast {
    println("test completed")
}
----

If you need to configure several properties or call multiple methods on the same task you can group them in a block as follows:

[source.multi-language-sample, groovy]
----
jar {
    archiveName = 'foo.jar'
    into('META-INF') {
        from('bar')
    }
}
----

[source.multi-language-sample, kotlin]
----
tasks.getByName<Jar>("jar") {
    archiveName = "foo.jar"
    into("META-INF") {
        from("bar")
    }
}
----

But there is another idiomatic way to configure tasks: using Kotlin link:https://kotlinlang.org/docs/reference/delegated-properties.html[delegated properties].
It is particularly useful if you need a reference to the task for later usage:

[source.multi-language-sample, groovy]
----
jar {
    archiveName = 'foo.jar'
}

jar.into('META-INF') {
    from('bar')
}
----

[source.multi-language-sample, kotlin]
----
val jar by tasks.getting(Jar::class) {
    archiveName = "foo.jar"
}

jar.into("META-INF") {
    from("bar")
}
----

Once again, note that if you need to apply task-specific configurations, you need to provide the type of the task (`Jar` in this example).

This means that you'll sometimes need to dive in the documentation or source code of custom plugins to discover what the types of its custom tasks are, and to import them, or use their fully qualified name.

Another way is to use the `tasks` task that display the list of available tasks. From there to get the type of a given task, say `jar`, use `./gradlew help --task jar`, this will tell you the type of that task.

This is particularly true if you are using an external plugin:

[source.multi-language-sample, groovy]
----
plugins {
    id('java')
    id 'org.springframework.boot' version '2.0.1.RELEASE'
}

repositories {
    jcenter()
}

apply plugin: 'io.spring.dependency-management'

bootJar {
    archiveName = 'app.jar'
    mainClassName = 'com.example.demo.Demo'
}

bootRun {
    main = 'com.example.demo.Demo'
    args '--spring.profiles.active=demo'
}
----

[source.multi-language-sample, kotlin]
----
import org.springframework.boot.gradle.tasks.bundling.BootJar
import org.springframework.boot.gradle.tasks.run.BootRun

plugins {
    java
    id("org.springframework.boot") version "2.0.1.RELEASE"
}

repositories {
    jcenter()
}

apply(plugin = "io.spring.dependency-management")

tasks {
    getByName<BootJar>("bootJar") {
        archiveName = "app.jar"
        mainClassName = "com.example.demo.Demo"
    }

    getByName<BootRun>("bootRun") {
        main = "com.example.demo.Demo"
        args("--spring.profiles.active=demo")
    }
}
----

In the Kotlin version of the snippet above we need to know that the `bootJar` task is of type `BootJar` and that the `bootRun` task is of type `BootRun`. The IDE then helps for adding the corresponding imports automatically.


=== Creating tasks

Creating tasks can be done on the `tasks` container:

[source.multi-language-sample, groovy]
----
task greeting {
    doLast { println("Hello, World!") }
}
----

[source.multi-language-sample, kotlin]
----
tasks.create("greeting") {
    doLast { println("Hello, World!") }
}
----

or directly from the top-level using the API functions available on `Project`:

[source.multi-language-sample, groovy]
----
task greeting {
    doLast { println("Hello, World!") }
}
----

[source.multi-language-sample, kotlin]
----
task("greeting") {
    doLast { println("Hello, World!") }
}
----

or by using Kotlin delegated properties that are useful if you need a reference to the created task for later usage:

[source.multi-language-sample, groovy]
----
task greeting {
    doLast { println("Hello, World!") }
}
----

[source.multi-language-sample, kotlin]
----
val greeting by tasks.creating {
    doLast { println("Hello, World!") }
}
----


Often you want to create a task of a given type (`Zip` in this example):

[source.multi-language-sample, groovy]
----
task docZip(type: Zip) {
    archiveName = 'doc.zip'
    from 'doc'
}
----

[source.multi-language-sample, kotlin]
----
tasks.create<Zip>("docZip") {
    archiveName = "doc.zip"
    from("doc")
}
----

The same thing can be done using the `Project` API:

[source.multi-language-sample, groovy]
----
task docZip(type: Zip) {
    archiveName = 'doc.zip'
    from 'doc'
}
----

[source.multi-language-sample, kotlin]
----
task<Zip>("docZip") {
    archiveName = "doc.zip"
    from("doc")
}
----

Or Kotlin delegated properties:

[source.multi-language-sample, groovy]
----
task docZip(type: Zip) {
    archiveName = 'doc.zip'
    from 'doc'
}
----

[source.multi-language-sample, kotlin]
----
val docZip by tasks.creating(Zip::class) {
    archiveName = "doc.zip"
    from("doc")
}
----


=== Dependencies and configurations

Declaring dependencies in the existing configurations is not much different from doing it in Groovy:

[source.multi-language-sample, groovy]
----
plugins {
    id 'java'
}
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'io.jsonwebtoken:jjwt:0.9.0'
    runtimeOnly 'org.postgresql:postgresql'
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude(module: 'junit')
    }
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}
----

[source.multi-language-sample, kotlin]
----
plugins {
    java
}
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("io.jsonwebtoken:jjwt:0.9.0")
    runtimeOnly("org.postgresql:postgresql")
    testImplementation("org.springframework.boot:spring-boot-starter-test") {
        exclude(module = "junit")
    }
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}
----

Note that if you do not use the `plugins {}` block to apply your plugins, then accessors to configurations contributed by the applied plugins won't be available. You'll then have to address them by name:

[source.multi-language-sample, groovy]
----
apply plugin: 'java'
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'io.jsonwebtoken:jjwt:0.9.0'
    runtimeOnly 'org.postgresql:postgresql'
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude(module: 'junit')
    }
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}
----

[source.multi-language-sample, kotlin]
----
apply(plugin = "java")
dependencies {
    "implementation"("org.springframework.boot:spring-boot-starter-web")
    "implementation"("io.jsonwebtoken:jjwt:0.9.0")
    "runtimeOnly"("org.postgresql:postgresql")
    "testImplementation"("org.springframework.boot:spring-boot-starter-test") {
        exclude(module = "junit")
    }
    "testRuntimeOnly"("org.junit.jupiter:junit-jupiter-engine")
}
----

or bring them into scope thanks to Kotlin delegated properties:

[source.multi-language-sample, groovy]
----
apply plugin: 'java'
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'io.jsonwebtoken:jjwt:0.9.0'
    runtimeOnly 'org.postgresql:postgresql'
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude(module: 'junit')
    }
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}
----

[source.multi-language-sample, kotlin]
----
apply(plugin = "java")
val implementation by configurations
val runtimeOnly by configurations
val testImplementation by configurations
val testRuntimeOnly by configurations
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("io.jsonwebtoken:jjwt:0.9.0")
    runtimeOnly("org.postgresql:postgresql")
    testImplementation("org.springframework.boot:spring-boot-starter-test") {
        exclude(module = "junit")
    }
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}
----


=== Custom configurations and dependencies

Sometimes you need to add your own configuration, and add dependencies to them:

[source.multi-language-sample, groovy]
----
configurations {
    db
    integTestImplementation {
        extendsFrom testImplementation
    }
}

dependencies {
    db 'org.postgresql:postgresql'
    integTestImplementation 'com.ninja-squad:DbSetup:2.1.0'
}
----

[source.multi-language-sample, kotlin]
----
val db by configurations.creating
val integTestImplementation by configurations.creating {
    extendsFrom(configurations["testImplementation"])
}

dependencies {
    db("org.postgresql:postgresql")
    integTestImplementation("com.ninja-squad:DbSetup:2.1.0")
}
----

Note that, in the above example, you can only use `db(...)` and `integTestImplementation(...)` because they're both declared as properties before. If they were defined elsewhere, you could get them by delegating to `configurations`, or you could use a string to add a dependency to the configuration:

.kotlin
[source, kotlin]
----
// get the existing testRuntimeOnly configuration
val testRuntimeOnly by configurations

dependencies {
    testRuntimeOnly("org.postgresql:postgresql")
    "db"("org.postgresql:postgresql")
    "integTestImplementation"("com.ninja-squad:DbSetup:2.1.0")
}
----

=== Extensions

Many plugins come with extensions to configure them. If those plugins are applied using the `plugins {}` block (which is true for the `jacoco` and the Spring Boot plugins in the following example), then Kotlin extension functions are made available to configure their extension, the same way as in Groovy.

On the other hand, if you use the older `apply` function to apply a plugin (which is true for the checkstyle plugin in the following example), you'll have to use the `configure<T> {}` function to configure them:

[source.multi-language-sample, groovy]
----
jacoco {
    toolVersion = "0.8.1"
}

springBoot {
    buildInfo {
        properties {
            time = null
        }
    }
}

checkstyle {
    maxErrors = 10
}
----

[source.multi-language-sample, kotlin]
----
jacoco {
    toolVersion = "0.8.1"
}

springBoot {
    buildInfo {
        properties {
            time = null
        }
    }
}

configure<CheckstyleExtension> {
    maxErrors = 10
}
----

[TIP]
The Gradle link:{user-manual}[user manual] and link:{guides}[guides] contain build script excerpts that demonstrate both the Groovy DSL and the Kotlin DSL.
This is the best place where to find how to do this and what with the Kotlin DSL ; and it covers all Gradle features from link:#TODO[using plugins] to link:#TODO[customizing the dependency resolution behavior].


=== Going from dynamic to static

Gradle core provides the base building blocks of the build model.
Both build and plugins authors interact with that build model through scripts and plugins.
Those interactions include contributing to the build model - e.g. adding configurations, tasks or extensions - and configuring elements of the build model - again, configurations, tasks, extensions etc…

The Gradle Java API allows build and plugin authors to interact with the build model using any JVM language. When using the Java API you need to query the model for elements contributed by plugins, mostly either by name, type or both.

On top of the Gradle Java API, the Gradle DSLs provide a more concise syntax.

Let’s look at an example. Let’s say we create a Gradle plugin implemented in Java that applies the `distribution` plugin then creates a `samples` distribution and declare its conventional content:

[source.java]
----
public class MyPlugin implements Plugin<Project> {
   @Override
   public void apply(final Project project) {

        project.getPlugins().apply("distribution");

        ExtensionContainer extensions = project.getExtensions();
        DistributionContainer distributions = extensions.getByType(DistributionContainer.class);
        Distribution samples = distributions.create("samples");
        samples.getContents().from(project.getLayout().getProjectDirectory().dir("src/samples"));
   }
}
----

It's verbose, but let not focus on that.

The `distribution` plugin contributes an extension to the project model named `distributions` and of type `DistributionContainer`.
The sample above queries the project model for that extension by type and then use it.
It could also have queried for the extension by name with `project.getExtensions().getByName("distributions")` but a cast to `DistributionContainer` would have been needed before interacting with it. In other words, models contributed by plugins are addressed by name, type or both.
That's a lot of ceremony.

The main goal of both Gradle DSLs is to reduce that ceremony. In both DSLs this is achieved by using a concise programming language, syntactic helpers plus constructs that make it easier to work with the Gradle extensible model.

Let's now look at the very same intent but implemented using the Groovy DSL,

[source, groovy]
----
plugins {
    id 'distribution'
}
distributions {
    samples {
        contents {
            from layout.projectDirectory.dir('src/samples')
        }
    }
}
----

and the Kotlin DSL:

[source, kotlin]
----
plugins {
    id("distribution")
}
distributions {
    create("samples") {
        contents {
            from(layout.projectDirectory.dir("src/samples"))
        }
    }
}
----

In both scripts above, the `distributions` extension of type `DistributionContainer` contributed by the `distribution` plugin is simply called out by name.
Both DSLs provide constructs to address model elements contributed by plugins.

In both scripts above, the `samples` distribution is created and configured on the `distributions` extension which is a link:{user-manual}custom_plugins.html#sec:maintaining_multiple_domain_objects[collection of objects] for which both the Groovy DSL and the Kotlin DSL provide syntactic helpers.

There are some differences, but the concerns are the same.

// TODO explain what happens in each case to make things very clear


== Migration strategies

Both scripts using the Kotlin DSL, `\*.gradle.kts`, and scripts using the Groovy DSL, `*.gradle`, can participate in the same build. Gradle plugins implemented in `./buildSrc`, an included build or externally fetched can use any JVM language. This makes it possible to migrate progressively, piece by piece, without blocking your team.

// TODO define/link "constraints", should be present in the user manual

Mechanical migration vs. restructuring towards best practices:

* both possible
* the former will be enough for simple builds
* a complex and highly dynamic build logic will require some restructuring
* external plugins might not provide a good Kotlin DSL experience, workarounds

[NOTE]
--
Depending on your build structure you might be interested by the following samples built with the Kotlin DSL:

* link to modularity sample
* link to multi-project samples
* link to gradle-plugin sample
* link to composite-builds sample
* link to source-control sample
--

Refactor towards the use of the `plugins {}` block using `pluginManagement {}` in `settings.gradle.kts` to control plugin resolution.

Refactor towards the use of `buildSrc` using the `kotlin-dsl` plugin.
// and pre-compiled scripts `buildSrc/src/main/kotlin/my-plugin.gradle.kts`


== Call Java or Groovy from Kotlin

* https://kotlinlang.org/docs/reference/java-interop.html[Calling Java from Kotlin]
* https://github.com/gradle/kotlin-dsl/blob/master/doc/getting-started/Closures.md[Invoking methods taking Groovy Closures] and the https://github.com/gradle/kotlin-dsl/tree/master/samples/groovy-interop[groovy-interop] sample
* `withGroovyBuilder {}` and the https://github.com/gradle/kotlin-dsl/tree/master/samples/maven-plugin[maven-plugin] sample


== Call Kotlin from Java or Groovy

* https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html[Calling Kotlin from Java]
* To call a Kotlin extension function from Groovy, call it as a static function passing the receiver as the first parameter.
* One can’t use kotlin functions with default parameters from groovy, one has to pass all parameters.


== Summary

*TBC*


include::contribute[]
