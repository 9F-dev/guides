= Migrating build logic from Groovy to Kotlin
:numbered:

Kotlin and Groovy languages are very different beasts, each with its own strengths.

Kotlin is statically typed and has null safety built-int and comes with top-notch IDE tooling from auto-completion to refactoring and everything in-between.

Groovy on the other hand is highly dynamic by nature, hence very flexible but lacking proper IDE tooling.

Gradle is implemented in Java on top of the JVM.
Both the Groovy DSL and the Kotlin DSL are implemented on top of the Gradle Java API.

[NOTE]
If you want to read on Kotlin the language before getting started or if you need some reference documentation along the way, the https://kotlinlang.org/docs/reference/[reference documentation] is the place to go.
The https://kotlinlang.org/docs/tutorials/koans.html[Kotlin Koans] provide a fun way to learn Kotlin.


== Groovy meet Kotlin

Kotlin the language is statically typed and has null safety built-int.
Groovy on the other hand is highly dynamic by nature.

* Kotlin language more strict than Groovy language
* Kotlin DSL more strict than Groovy DSL

Both DSLs provide means to interact with the Gradle dynamic and extensible model, and runtime.

With the Kotlin DSL:

* more ceremony to do dynamic things, some limitations with helpers
* more safety, more tooling


Applying Gradle best practices tend towards more declarative builds, less dynamic constructs. This is where the Kotlin DSL shines with the less ceremony and the more tooling. In that sense, the Kotlin DSL encourages Gradle best practices.

Applying Gradle best practices will make it much easier with the Kotlin DSL

[TIP]
--
* link to Gradle Kotlin DSL presentation in manual
* link to Gradle best practices in manual and guides
--

== A taste at the differences

To get started we will look at the main differences between the Groovy DSL and the Kotlin DSL from a scripting point of view. You can switch from Groovy script excerpts to Kotlin ones to see the differences.

* File names
* Applying plugins
* Working with tasks
* Dependencies and configurations
* Properties
* Live collections and containers
* Extensions

[TIP]
The Gradle link:{user-manual}[user manual] and link:{guides}[guides] contain build script excerpts that demonstrate both the Groovy DSL and the Kotlin DSL.
This is the best place where to find how to do this and what with the Kotlin DSL ; and it covers all Gradle features from link:#TODO[using plugins] to link:#TODO[customizing the dependency resolution behavior].


=== Going from dynamic to static

Gradle core provides the base building blocks of the build model.
Both build and plugins authors interact with that build model through scripts and plugins.
Those interactions include contributing to the build model - e.g. adding configurations, tasks or extensions - and configuring elements of the build model - again, configurations, tasks, extensions etc…

The Gradle Java API allows build and plugin authors to interact with the build model using any JVM language. When using the Java API you need to query the model for elements contributed by plugins, mostly either by name, type or both.

On top of the Gradle Java API, the Gradle DSLs provide a more concise syntax.

Let’s look at an example. Let’s say we create a Gradle plugin implemented in Java that applies the `distribution` plugin then creates a `samples` distribution and declare its conventional content:

[source.java]
----
public class MyPlugin implements Plugin<Project> {
   @Override
   public void apply(final Project project) {

        project.getPlugins().apply("distribution");

        ExtensionContainer extensions = project.getExtensions();
        DistributionContainer distributions = extensions.getByType(DistributionContainer.class);
        Distribution samples = distributions.create("samples");
        samples.getContents().from(project.getLayout().getProjectDirectory().dir("src/samples"));
   }
}
----

It's verbose, but let not focus on that.

The `distribution` plugin contributes an extension to the project model named `distributions` and of type `DistributionContainer`.
The sample above queries the project model for that extension by type and then use it.
It could also have queried for the extension by name with `project.getExtensions().getByName("distributions")` but a cast to `DistributionContainer` would have been needed before interacting with it. In other words, models contributed by plugins are addressed by name, type or both.
That's a lot of ceremony.

The main goal of both Gradle DSLs is to reduce that ceremony. In both DSLs this is achieved by using a concise programming language, syntactic helpers plus constructs that make it easier to work with the Gradle extensible model.

Let's now look at the very same intent but implemented using the Groovy DSL,

[source, groovy]
----
plugins {
    id 'distribution'
}
distributions {
    samples {
        contents {
            from layout.projectDirectory.dir('src/samples')
        }
    }
}
----

and the Kotlin DSL:

[source, kotlin]
----
plugins {
    id("distribution")
}
distributions {
    create("samples") {
        contents {
            from(layout.projectDirectory.dir("src/samples"))
        }
    }
}
----

In both scripts above, the `distributions` extension of type `DistributionContainer` contributed by the `distribution` plugin is simply called out by name.
Both DSLs provide constructs to address model elements contributed by plugins.

In both scripts above, the `samples` distribution is created and configured on the `distributions` extension which is a link:{user-manual}custom_plugins.html#sec:maintaining_multiple_domain_objects[collection of objects] for which both the Groovy DSL and the Kotlin DSL provide syntactic helpers.

There are some differences, but the concerns are the same.

// TODO explain what happens in each case to make things very clear


== Migration strategies

Both scripts using the Kotlin DSL, `\*.gradle.kts`, and scripts using the Groovy DSL, `*.gradle`, can participate in the same build. Gradle plugins implemented in `./buildSrc`, an included build or externally fetched can use any JVM language. This makes it possible to migrate progressively, piece by piece, without blocking your team.

// TODO define/link "constraints", should be present in the user manual

Mechanical migration vs. restructuring towards best practices:

* both possible
* the former will be enough for simple builds
* a complex and highly dynamic build logic will require some restructuring
* external plugins might not provide a good Kotlin DSL experience, workarounds

[NOTE]
--
Depending on your build structure you might be interested by the following samples built with the Kotlin DSL:

* link to modularity sample
* link to multi-project samples
* link to gradle-plugin sample
* link to composite-builds sample
* link to source-control sample
--

Refactor towards the use of the `plugins {}` block using `pluginManagement {}` in `settings.gradle.kts` to control plugin resolution.

Refactor towards the use of `buildSrc` using the `kotlin-dsl` plugin.
// and pre-compiled scripts `buildSrc/src/main/kotlin/my-plugin.gradle.kts`


== Call Java or Groovy from Kotlin

* https://kotlinlang.org/docs/reference/java-interop.html[Calling Java from Kotlin]
* https://github.com/gradle/kotlin-dsl/blob/master/doc/getting-started/Closures.md[Invoking methods taking Groovy Closures] and the https://github.com/gradle/kotlin-dsl/tree/master/samples/groovy-interop[groovy-interop] sample
* `withGroovyBuilder {}` and the https://github.com/gradle/kotlin-dsl/tree/master/samples/maven-plugin[maven-plugin] sample


== Call Kotlin from Java or Groovy

* https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html[Calling Kotlin from Java]
* To call a Kotlin extension function from Groovy, call it as a static function passing the receiver as the first parameter.
* One can’t use kotlin functions with default parameters from groovy, one has to pass all parameters.


== Summary

*TBC*


include::contribute[]
