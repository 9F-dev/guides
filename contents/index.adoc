= Testing Gradle plugins
:toclevels: 2
:numbered:

With practice writing Gradle plugins comes easy especially with the knowledge of the link:https://guides.gradle.org/implementing-gradle-plugins/[Implementing Gradle plugins] guide under your belt. Part of every development process is testing whether that’s in a manual or automated fashion. The same is true for Gradle plugin code. Before letting any consumer use a plugin its functionality should be verified on different levels. In this guide you will learn how to debug plugin code during development. You will also getting to know the techniques used to write and execute different types of tests.

This guide assumes you have:

- Basic understanding of software engineering practices
- Knowledge of Gradle plugin implementation techniques
- Working knowledge in writing Java code

If you happen to be a beginner to Gradle please start by working through the link:https://gradle.org/guides#getting-started[Getting Started Guides on Gradle development] first while referencing the {user-manual}userguide.html[Gradle User Manual] to go deeper.

== The sample project

All discussions around testing in this guide are based on a sample project called URL verifier plugin. The plugin creates a task named `verifyUrl` that checks whether a given URL can be resolved via HTTP GET. The URL can be provided through an extension named `verification` in the consuming build script. You can inspect and download the link:https://github.com/gradle-guides/testing-gradle-plugins/tree/master/samples/code/url-verifier-plugin[source code of the plugin] in the corresponding GitHub repository.

The following build script demonstrates a build script consuming the plugin.

.build.gradle
[source,groovy]
----
include::{samplescodedir}/include-plugin-build/build.gradle[tags=apply-configure-plugin]
----
<1> Applies the plugin to the project
<2> Configures the URL to be verified through the exposed extension

Executing the task provided by the plugin renders a success message if the HTTP GET call to the configured URL returns with a 200 response code.

[source,shell]
----
$ gradle verifyUrl

include::{samplesoutputdir}/consumer/verify-url.out[]
----

The following sections will discuss how to effectively test the plugin manually and in an automated fashion. Before diving into the code, let's first identify the different types of tests.

== On the importance of testing

Testing is a foundational activity in the software development lifecycle. Appropriate testing ensures that the software works on a functional and non-functional level before it is released to the end user. Furthermore, automated testing also enables the development team to refactor and evlove the code without fearing to introduce regressions in the process.

=== The testing pyramid

image::testing-pyramid.png[float=right]

Probably the easiest way to test software is to manually exercise it. **Manual testing** can occur at any time is is not bound to writing automation code. However, manual testing is error-prone and cumbersome as it requires a human to walk through a set of predefined test cases.

In contrast to manual testing, other types of tests can be fully automated and run with every change to the code. The testing pyramid introduced by Mike Cohen in his book link:https://www.mountaingoatsoftware.com/books/succeeding-with-agile-software-development-using-scrum[Succeeding with Agile: Software Development Using Scrum] describes three types of automated tests with tradeoffs in regards to the quantity of those tests, their maintaince costs and the time it takes to execute them.

**Unit testing** aims to verify the smallest unit of code. In Java-based projects this unit is a method. Unit tests usually do not interact with other parts of the system e.g. a database or the file system. Any references are isolated by replacing the interaction with Stubs or Mocks. For Gradle plugin implementations, the unit under test is a POJO or utility class that doesn't use the Gradle API.

**Integration testing** verifies that multiple classes or components work together as a whole. The code under test may reach out to external subsystems or use the Gradle API.

**Functional testing** is used to test the system from an end user's perspective. End-to-end tests for Gradle plugins stand up a build script, apply the plugin under test and execute the build with a specific task. The outcome of the build (e.g. standard output/error or generated artifacts) verfies the correctness of the functionality.

=== Tooling support

Implementing manual and automated testing for Gradle plugins is straight forward - it just requires the right tooling. The table below gives you a brief overview on how to approach each test type. Please be aware that you have the free choice of using the test framework you are most familiar with. For a detailed discussion and code example please refer to the dedicated section in this guide.

[cols="20%,80%",options="header"]
|======================
|Test type                               |Tooling support
|<<manual-tests,Manual tests>>           |{user-manual}composite_builds.html[Gradle composite builds]
|<<unit-tests,Unit tests>>               |Any JVM-based test framework
|<<integration-tests,Integration tests>> |Any JVM-based test framework and {api-reference}org/gradle/testfixtures/ProjectBuilder.html[Gradle's ProjectBuilder API]
|<<functional-tests,Functional tests>>   |Any JVM-based test framework and {user-manual}test_kit.html[Gradle TestKit]
|======================

[[manual-tests]]
== Setting up manual tests

One way to test a plugin in a consuming project is to publish the plugin JAR file to a local repository and point the project it. Granted this technique is cumbersome - every change to the plugin code requires the developer to publish a new artifact.

With the introduction of the {user-manual}composite_builds.html[composite builds] feature, plugin developers have a more powerful mechanism at their disposal. The standalone plugin project and the consuming project can be combined together into a single unit making it much more straight forward to try out or debug changes without the hassle of re-publishing the binary file.

----
.
├── include-plugin-build   // <1>
│   ├── build.gradle
│   └── settings.gradle
└── url-verifier-plugin    // <2>
    ├── build.gradle
    ├── settings.gradle
    └── src
----
<1> Consuming project that includes the plugin project
<2> The plugin project

There are two ways to include a plugin project into a consuming project.

1. By using the command line option `--include-build`.
2. By using the method `includeBuild` in `settings.gradle`.

The following code snippet demonstrates the use of the settings file.

.settings.gradle
[source,groovy]
----
include::{samplescodedir}/include-plugin-build/settings.gradle[tags=include-build]
----

The execution of the project `include-plugin-build` in plain console mode clearly shows that the plugin project became part of a multi-project build.

[source,shell]
----
$ gradle verifyUrl --console=plain

include::{samplesoutputdir}/composite-build/verify-url.out[]
----

Next up, you'll learn how to implement automated tests for Gradle plugins.

== Setting up automated tests

Setting up a suite of tests earlier on the project lifecycle is crucial to the success of your plugin. You will encounter various situations that make your tests an invaluable safety net e.g. when upgrading the plugin to a new Gradle version and enhancing or refactoring the code.

=== Organizing test source code

To cover the most important use cases with test code a good distribution of unit, integration and functional tests is recommended. Separating the source code for each test type automatically results in a more maintainable and manageable project. By default the Java project already creates a convention for organizing unit tests, the directory `src/test/java`, or if the Groovy plugin is applied, `src/test/groovy`. Consequently, source code directories for other test types should follow a similar pattern. Below you can find an exemplary project layout for a plugin project that chooses to use a Groovy-based testing approach.

----
.
└── src
    ├── functTest
    │   └── groovy      // <1>
    ├── integTest
    │   └── groovy      // <2>
    ├── main
    │   ├── java        // <3>
    │   └── resources   // <4>
    └── test
        └── groovy      // <5>
----
<1> Source directory containing functional tests
<2> Source directory containing integration tests
<3> Source directory containing production source code
<4> Source directory containing production resource files
<5> Source directory containing unit tests

NOTE: The directories `src/integTest/groovy` and `src/functTest/groovy` are not based on an existing standard convention for Gradle projects. You can free to choose any project layout that works best for you.

In the next section, you will learn how to configure those source directories for compilation and test execution.

=== Modeling test types

Gradle models source code directories with the help of the {user-manual}java_plugin.html#sec:working_with_java_source_sets[source set concept]. By pointing an instance of a source set to one or many source code directories, Gradle will automatically creating a corresponding compilation task out-of-the-box. The following script plugin demonstrates the creation of a source set for integration tests.

.integration-test.gradle
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/gradle/integration-test.gradle[tags=test-source-set]
----

Source sets are only responsible for compiling source code but do not deal with executing the byte code. For the purpose of test execution, a corresponding task of type {api-reference}org/gradle/api/tasks/testing/Test.html[Test] needs to be established. The following task demonstrate the setup for executing integration tests. As you can see in the task configuring the classes and runtime classpath of the integration test source set is referenced.

.integration-test.gradle
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/gradle/integration-test.gradle[tags=test-task]
----

=== Configuring a test framework

Writing test code for Gradle plugin is not bound to a specific test framework. Popular choices include link:http://junit.org/junit4/[JUnit], link:http://testng.org/[TestNG] and link:http://spockframework.org/[Spock]. Once you choose an option, you have to add it to the compile classpath for your tests. The following code snippet shows how to use Spock for implementing tests.

.build.gradle
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/build.gradle[tags=test-framework]
----

NOTE: Spock is a Groovy-based BDD test framework that even includes APIs for creating Stubs and Mocks. The Gradle team prefers the Spock over other options for its expressiveness and conciseness.

With the knowledge of setting up test source sets and tasks, let's also discuss an concrete example for unit, integration and functional tests. All examples are based on Spock.

== implementing automated tests

[[unit-tests]]
=== Implementing unit tests

The URL verifier plugin emits HTTP GET calls to check if a URL can be resolved successfully. The method `DefaultHttpCaller.get(String)` is responsible for calling a given URL and returns with an instance of type `HttpResponse`. `HttpResponse` is a POJO containing information about the HTTP response code and message.

.HttpResponse.java
[source,java]
----
include::{samplescodedir}/url-verifier-plugin/src/main/java/org/gradle/sample/http/HttpResponse.java[]
----

The class `HttpResponse` represents a good candidate to be tested by a unit test. It does not reach out to any other classes nor does it use the Gradle API.

.HttpResponseTest.groovy
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/src/test/groovy/org/gradle/sample/http/HttpResponseTest.groovy[]
----

[[integration-tests]]
=== Implementing integration tests

Integration tests might or might not use the Gradle API. This section of the guide explains solutions for both situations. 

==== Class under test does not use Gradle API

First, we'll have a look at a class that reaches out to a another system, the piece of code that emits the HTTP calls. At the time of executing a test for the class `DefaultHttpCaller`, the runtime environment needs to be able to reach out to the internet.

.DefaultHttpCaller.java
[source,java]
----
include::{samplescodedir}/url-verifier-plugin/src/main/java/org/gradle/sample/http/DefaultHttpCaller.java[]
----

Implementing an integration test for `DefaultHttpCaller` doesn't look much different from the unit test shown in the previous section. In fact there's nothing special to it.

.DefaultHttpCallerIntegrationTest.groovy
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/src/integTest/groovy/org/gradle/sample/http/DefaultHttpCallerIntegrationTest.groovy[]
----

==== Class under test uses Gradle API

The task type responsible for verifying a URL is actually a more interesting example. It not only calls an URL via HTTP and verifies the response but also heavily leverages the Gradle API. The Gradle task is created by the plugin. However, if you wanted to create an integration test for just the task type then you don't necessarily want to test the plugin implementation as well.

.UrlVerify.java
[source,java]
----
include::{samplescodedir}/url-verifier-plugin/src/main/java/org/gradle/sample/tasks/UrlVerify.java[]
----

An effective way to creating task instance in an integration is the `ProjectBuilder` API. `ProjectBuilder` is a public API that gives you an entry point for creating a `Project` instance. To be able to use the `ProjectBuilder` API the test setup needs to declare a references to the Gradle API.

.integration-test.gradle
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/gradle/integration-test.gradle[tags=gradle-api]
----

WARNING: The created `Project` instance acts as a stand-in object that _almost_ behaves like a real instance. There are certain limitations for this `Project` instance e.g. it doesn't automatically invoke project lifecycle hooks like `afterEvaluate`. If you happen to run into those limitations then writing a <<functional-tests,functional test>> is likely the better option. In the long run, `ProjectBuilder` might become a more powerful API.

The following integration tests demonstrates the use of `ProjectBuilder`. The `setup` method first creates a `Project` instance and then a task instance of type `UrlVerify`. The test code mocks the HTTP communication so that each test code can solely concentrate on verifying the correct behavior of the task.

.UrlVerifyIntegrationTest.groovy
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/src/integTest/groovy/org/gradle/sample/tasks/UrlVerifyIntegrationTest.groovy[]
----

[[functional-tests]]
=== Implementing functional tests

Functional tests verify the correctness of the plugin end-to-end. Practically that means applying, configuring and executing the functionality the plugin implementation. The class `UrlVerifierPlugin` shows the actual plugin implementation of the URL verifier. As you can see, the class exposes an extension and a task instances that uses the URL value confiured bt the end user.

.UrlVerifierPlugin.java
[source,java]
----
include::{samplescodedir}/url-verifier-plugin/src/main/java/org/gradle/sample/UrlVerifierPlugin.java[]
----

Every Gradle plugin project should apply the {user-manual}javaGradle_plugin.html[plugin development plugin] to reduce boilerplate code. By applying the plugin development plugin, the project is preconfigured to use TestKit. Now that we use a different source set for functional tests than then standard one, you have to point it to it.

.functional-test.gradle
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/gradle/functional-test.gradle[tags=source-set-config]
----

Functional tests for Gradle plugins use a instance of `GradleRunner` to execute the build under test. `GradleRunner` is an API provided by TestKit which internally uses the Tooling API to execute the build. The following example applies the plugin to the build script under test, configures the extension and executes the build with the task `verifyUrl`. Please see the {user-manual}test_kit.html[TestKit documentation] to get more familiar with the functionality of TestKit.

.UrlVerifierPluginFunctionalTest.groovy
[source,groovy]
----
include::{samplescodedir}/url-verifier-plugin/src/functTest/groovy/org/gradle/sample/UrlVerifierPluginFunctionalTest.groovy[]
----

== Summary

Please let us know on the link:https://discuss.gradle.org/[Gradle forum] if you are still having difficulties understanding any of the covered testing strategies. Which one works the best for your plugin? Let us know!

Wrote an awesome plugin? Write a tweet to link:https://twitter.com/gradle[@gradle] with the link to the documentation or code.

== Next steps

Testing Gradle plugins builds upon best practices and development strategies. You may be interested in:

- link:https://guides.gradle.org/designing-gradle-plugins/[Designing Gradle plugins]
- link:https://guides.gradle.org/implementing-gradle-plugins/[Implementing Gradle plugins]
